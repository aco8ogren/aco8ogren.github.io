<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js DOF Background — MWE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Fullscreen, fixed, behind-page canvas */
    #bg {
      position: fixed;
      inset: 0;
      z-index: -1;
      display: block;
      pointer-events: none; /* don't block clicks on the page */
    }
    /* Just to give you something to scroll */
    main {
      min-height: 300vh;
      padding: 4rem clamp(1rem, 5vw, 4rem);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    h1 { font-size: clamp(2rem, 5vw, 3rem); margin: 0 0 1rem; }
    p  { max-width: 70ch; }
    .card {
      max-width: 60ch;
      background: rgba(255,255,255,0.7);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      border-radius: 12px;
      padding: 1rem 1.25rem;
      margin: 1rem 0;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <main>
    <h1>Three.js Depth-of-Field Background</h1>
    <div class="card">
      <p>Scroll and watch the parallax. Squares at different depths fall and rotate.
         Depth of field is applied via a Bokeh post-processing pass. You’ll wire real
         leaf physics later.</p>
    </div>
    <div class="card">
      <p><strong>Tune DOF:</strong> open the code and adjust <code>focus</code>,
         <code>aperture</code>, and <code>maxblur</code>. Focus is a distance from
         the camera in world units.</p>
    </div>
  </main>

  <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.159.0/build/three.module.js";
    import { EffectComposer } from "https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/RenderPass.js";
    import { BokehPass } from "https://unpkg.com/three@0.159.0/examples/jsm/postprocessing/BokehPass.js";

    // ---------- renderer / canvas ----------
    const canvas   = document.getElementById('bg');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    const DPR      = Math.min(window.devicePixelRatio || 1, 2);
    renderer.setPixelRatio(DPR);
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // ---------- scene / camera ----------
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 0, 20); // look toward origin

    // ---------- lights (subtle) ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5, 10, 10);
    scene.add(dir);

    // ---------- squares (instanced for perf) ----------
    const COUNT   = 400;         // number of quads
    const SIZE    = 0.6;         // side length
    const DEPTH_Z = 60;          // depth spread (±)
    const X_SPAN  = 70;          // lateral spread
    const Y_SPAN  = 120;         // vertical spread

    const geom = new THREE.PlaneGeometry(SIZE, SIZE);
    const mat  = new THREE.MeshStandardMaterial({
      color: 0x3f7cff,
      metalness: 0.05,
      roughness: 0.9,
      side: THREE.DoubleSide
    });

    const mesh = new THREE.InstancedMesh(geom, mat, COUNT);
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(mesh);

    // Per-instance state
    const states = new Array(COUNT).fill().map(() => ({
      x: (Math.random() - 0.5) * X_SPAN,
      y: (Math.random() - 0.5) * Y_SPAN,
      z: (Math.random() * 2 - 1) * DEPTH_Z,  // near/far for DOF
      vy: 0.4 + Math.random() * 0.8,         // fall speed
      rx: Math.random() * Math.PI * 2,       // rotation angles
      ry: Math.random() * Math.PI * 2,
      rz: Math.random() * Math.PI * 2,
      wrx: (Math.random() - 0.5) * 0.6,      // angular velocities
      wry: (Math.random() - 0.5) * 0.6,
      wrz: (Math.random() - 0.5) * 0.6,
      hue: Math.random()
    }));

    // optional: color variance
    const colors = new Float32Array(COUNT * 3);
    for (let i = 0; i < COUNT; i++) {
      const c = new THREE.Color().setHSL(states[i].hue, 0.5, 0.6);
      colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
    }
    mesh.instanceColor = new THREE.InstancedBufferAttribute(colors, 3);

    // ---------- postprocessing: DOF ----------
    const composer  = new EffectComposer(renderer);
    composer.setSize(innerWidth, innerHeight);

    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // DOF controls: focus, aperture, maxblur
    const bokehPass = new BokehPass(scene, camera, {
      focus: 20,         // distance from camera that is in focus
      aperture: 0.00015, // blur strength (≈ f-stop; small numbers)
      maxblur: 0.002      // clamp blur radius
      // width/height default to renderer size
    });
    composer.addPass(bokehPass);

    // ---------- helpers ----------
    const tmpMat = new THREE.Matrix4();
    const tmpQ   = new THREE.Quaternion();

    function resetInstance(s) {
      s.x  = (Math.random() - 0.5) * X_SPAN;
      s.y  = (Math.random() - 0.5) * Y_SPAN - Y_SPAN * 0.5; // spawn above
      s.z  = (Math.random() * 2 - 1) * DEPTH_Z;
      s.vy = 0.4 + Math.random() * 0.8;
    }

    // ---------- resize ----------
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    }, { passive: true });

    // ---------- animation ----------
    let last = performance.now();
    function tick(now = performance.now()) {
      const dt = Math.min((now - last) / 1000, 0.05); // clamp delta
      last = now;

      // Parallax with scroll: camera eases toward scroll offset
      const targetY = (scrollY / innerHeight) * 20; // tune parallax
      camera.position.y += (targetY - camera.position.y) * 0.08;

      // Update instances
      for (let i = 0; i < COUNT; i++) {
        const s = states[i];
        s.y += s.vy * dt * 8;           // fall (positive y is down with default)
        s.rx += s.wrx * dt; s.ry += s.wry * dt; s.rz += s.wrz * dt;

        // recycle when out of view (below)
        if (s.y > Y_SPAN * 0.6) resetInstance(s);

        // write transform
        tmpQ.setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz));
        tmpMat.compose(
          new THREE.Vector3(s.x, s.y - camera.position.y * 0.4, s.z), // subtle parallax
          tmpQ,
          new THREE.Vector3(1, 1, 1)
        );
        mesh.setMatrixAt(i, tmpMat);
      }
      mesh.instanceMatrix.needsUpdate = true;

      // Render with DOF
      composer.render();
      requestAnimationFrame(tick);
    }
    tick();

    // ---------- quick tweak hooks in console ----------
    //   bokehPass.materialBokeh.uniforms.focus.value = 28;
    //   bokehPass.materialBokeh.uniforms.aperture.value = 0.00025;
    //   bokehPass.materialBokeh.uniforms.maxblur.value = 0.03;
  </script>
</body>
</html>
